# 第一章 什么是作用域

提出问题

1. js中的变量存储在哪儿
2. 程序如何在需要的时候找到它们

## 编译器理论

尽管JavaScript一般被划分到"动态"或者"解释型"语言的范畴，但是实际它是一个**编译型**语言。只不过它不像许多传统意义上的编译型语言那样预先被编译好，编译结果也不能在各个不同的分布式系统间移植。

传统的编译型语言处理中，源代码在执行前会经历三个步骤，大致称为"编译":

1. 分词/词法分析：将一连串字符打断成有意义的片段，称为token。
2. 解析： 将一个token的流(数组)转换为一个嵌套元素的树，它综合地展示了程序的语法结构。这棵树称为"抽象语法树"。
3. 代码生成：这个处理将抽象语法树转换为可执行的代码。

任何js代码在它执行前(通常是刚好在它执行前！)都必须被编译。所以，js编译器将把程序`var a = 2`;拿过来，首先编译它，然后准备运行它，通常是立即的。

## 理解作用域

### 演员

处理程序`var a = 2;`时进行互动的演员

1. 引擎：负责从始至终的编译和执行我们的js程序。
2. 编译器：引擎的朋友之一；处理所有的解析和代码生成的重活儿。 
3. 作用域：引擎的另一个朋友；收集并维护一张所有被声明的标识符(变量)的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。

### 反复

编译器处理：

1. 遇到`var a`,编译器让作用域去查看对于这个特定的作用域集合，变量`a`是否已经存在了。如果是，编译器就忽略这个声明并继续前进。否则，编译器就让作用域为这个作用域集合声明一个称为`a`的新变量。
2. 然后编译器为引擎生成稍后要执行的代码，来处理赋值`a = 2`。引擎运行的代码首先让作用域去查看在当前的作用域集合中是否有一个称为`a`的变量可以访问。如果有，引擎就使用这个变量。如果没有，引擎就查看其它地方(作用域嵌套)。

如果引擎最终找到了一个变量，它就将值`2`赋予它。如果没有，引擎将会举起它的手并喊出错误。

### 编译术语

当引擎执行编译器在第二步为它产生的代码时，它必须查询变量`a`看它是否已经被声明过了，而且这个查询是资讯作用域的。但是引擎所实施的查询的类型会影响查询的结果。

在我们的例子中，引擎将会对变量`a`实施一个"LHS"查询。另一种类型的查询称为"RHS"。
当一个变量出现在赋值操作的左手边时，会进行LHS查询，当一个变量出现在赋值操作的右边时，会进行RHS查询。

RHS是难以察觉的，因为它简单地查询某个变量的值，而LHS查询是试着找到变量容器本身，以便它可以赋值。

```js
console.log(a);
```

这个指向`a`的引用是一个RHS引用，因为这里没有东西被赋值给`a`。而是我们在查询`a`并且取它的值，这样这个值可以被传递进`console.log(...)`。

**注意**: LHS和RHS意味着"赋值的左/右手边"未必像字面上那样意味着"=赋值操作符的左/右边"。赋值有几种其他的发生形式，所以最好在概念上讲它考虑为："赋值的目标(LHS)和赋值的源(RHS)"。

考虑这段程序，它既有LHS引用又有RHS引用：

```js
function foo(a){
  console.log( a ); // 2
}

foo( 2 );
```
调用`foo(..)`的最后一行作为一个函数调用要求指向`foo`的RHS引用，意味着，"去查询`foo`的值，并把它交给我"。另外，`(..)`意味着`foo`的值应当被执行，所以它最好实际上是一个函数！

这里有一个微妙但重要的赋值`a = 2`。它发生在当值`2`作为参数传递给`foo(..)`函数时，值`2`被赋值给了参数`a`.为了(隐含地)给参数`a`赋值，进行了一个LHS查询。

这里还有一个`a`的值的RHS引用，它的结果值被传入`console.log(..)`。`console.log(..)`需要一个引用来执行。它为`console`对象进行一个RHS查询，然后发生一个属性解析来看它是否拥有一个称为`log`的方法。

最后，我们可以将这一过程概念化为，在将值`2`(通过变量`a`的RHS查询得到的)传入`log()..`时发生了一次LHS/RHS的交换。在`log(..)`的原生实现内部，我们可以假定它拥有参数，其中的第一个(也许被称为arg1)在`2`被赋值给它之前，进行了一次LHS引用查询。

**注意**:你可能会试图将函数声明`function foo(a){..`概念化为一个普通的变量声明和赋值，比如`var foo`和`foo = funtion(a){..`。这样做会诱使你认为函数声明涉及了一次LHS查询。

然而，一个微妙但是重要的不同是，在这种情况下编译器在代码生成期间同时处理声明和值的定义，如此当引擎执行代码时，没有必要将一个函数值"赋予"`foo`。因此，将函数声明考虑为一个我们在这里讨论的LHS查询赋值是不太合适的。 

### 嵌套作用域

就像一个代码块儿或函数被嵌套在另一个代码块或函数中，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，引擎就会咨询下一个外层作用域，如果继续直到找到这个变量或者到达最外层作用域(也就是全局作用域)。

为了将嵌套作用域解析的过程可视化，考虑一下这个高层建筑。

<img src="images/fig1.png" width=400 height=560 />

这个建筑物表示我们程序的嵌套作用域规则集合。无论你在哪里，建筑的第一层表示你当前执行的作用域。建筑的顶层表示全局作用域。

你通过在你当前的楼层中查找来解析LHS和RHS引用，如果你没有找到它，就坐电梯到上一层楼，在那里寻找，然后再上一层，如此类推。一旦你到了顶层(全局作用域)，你要么找到了你想要的东西，要么没有。但是不管怎么样你都不得不停止了。

### 错误
为什么我们区别LHS和RHS那么重要？

因为在变量还没有被声明(在所有查询的作用域中没有都找到)的情况下，这两种类型的查询的行为不同。

考虑如下代码:

```js
function(a){
  console.log(a + b);
  b = a;
}

foo(2);
```

当`b`的RHS查询第一次发生时，它是找不到的。它被说成是一个"未声明"的变量，因为它在作用域中招不到。

如果RHS查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个`ReferenceError`。必须要注意的是这个错误的类型是`ReferenceError`。

相比之下，如果引擎在进行一个LHS查询，但到达了顶层(全局作用域)都没有找到它，而且如果程序没有运行在"Strict"模式下，那么这个全局作用域将会在全局作用域中创建一个同名的新变量，并把它交给引擎。

现在，如果一个RHS查询的变量被找到了，但是你试着去做一些这个值不可能做的事情，比如讲一个非函数的值作为函数运行，或者`null`或者`undefined`值的属性，那么引擎就会抛出一个不同种类的错误，称为`TypeError`。

`ReferenceError`是关于作用域解析失败的，而`TypeError`暗示着作用域解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。