# 第五章：作用域闭包

希望我们是带着对作用域工作方式的健全，坚实的理解来到这里的。

我们将我们的注意力转向这个语言中一个重要到不可思议，但是一直难以捉摸的，几乎是神话般的部分：**闭包**。如果你至此一直跟随我们关于词法作用域的讨论，那么你也会感觉闭包在很大程度上没那么令人激动，几乎是显而易见的。有一个魔法师坐在幕后，现在我们即将见到他。

## 启蒙

对于那么些对JavaScript有些经验，但是也许从没有全面掌握闭包概念的人来说，闭包看起来就像是必须努力并作出牺牲才能到达的涅槃状态。

回想几年前我对JavaScript有了牢固的掌握，但是不知道闭包是什么。它暗示着这种语言有着另外的一面，它许诺了甚至比我已经拥有的还多的力量，它取笑并嘲弄我。我记得我通读早期框架的源码视图搞懂它到底是如何工作的。我记得第一次"模块模式"的某些东西融入我的大脑。

那时我不明白的东西，那个花了我好几年时间才搞懂的东西，那个我即将传授给你的东西，是这个秘密：**在JavaScript中闭包无所不在，你只是必须认出它并且接纳它**。闭包不是你必须学习新的语法和模式才能使用的特殊的可选的工具。

闭包是依赖于词法作用域编写代码产生的结果。他们就这么发生了。要利用他们你甚至不需要有意的创建闭包。闭包在你的代码中一直在被创建和使用。你缺少的是恰当的思维环境，来识别，接纳，并以自己的意志利用闭包。

启蒙的时刻应该是： **哦，闭包已经在我的代码中到处发生了，现在我终于看到她们了**。理解闭包就像是欧尼第一次看到母体。

## 事实真相

为了理解和识别闭包，这里有一个你需要知道的简单粗暴的定义：

> 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。

```js
function foo(){
  var a = 2;

  function bar(){
    console.log(a); // 2
  }

  bar();
}

foo();
```

根据我们对嵌套作用域的讨论，这段代码应当看起来很熟悉。由于词法作用域查询规则(在这个例子中， 是一个RHS引用查询)，函数`bar()`可以访问外围作用域的变量`a`。

这是闭包吗？

好吧，从技术上讲......也许是。但是根据我们上面的"你需要知道"的定义...不确切。我认为解释`bar()`应用`a`的最准确的方式是根据词法作用域查询规则，但是那些规则仅仅是闭包的(一个很重要的!)一部分。

从纯粹的学院派角度讲，上面的代码被认为是函数`bar()`在函数`foo()`的作用域上有一个闭包(而且实际上，它甚至对其他的作用域也可以访问，比如这个例子中的全局作用域)。换一种略有不同的说法是，`bar()`闭住了`foo()`的作用域。为什么？因为`bar()`嵌套地出现在`foo()`内部。就这么简单。

但是这样一来闭包的定义就是不能直接观察到了的了，我们也不能看到闭包在这个代码段中被执行。我们清楚地看到词法作用域，但是闭包仍然像代码后面谜一般的模糊阴影。

让我们考虑这段将闭包完全带到聚光灯下的代码：

```js
function foo(){
  var a = 2;

  function bar(){
    console.log(a);
  }

  return bar;
}

var baz = foo();

baz(); //2 -- 看到闭包了
```

函数`bar()`对于`foo()`内的作用域有词法作用域访问权。但是之后，我们拿起`bar()`,这个函数本身，将它像值一样传递。在这个例子中，我们`return bar`引用的函数对象本身。

在执行`foo()`之后，我们将它返回的值(我们的内部`bar()`函数)赋予一个称为`baz`的变量，然后我们实际地调用`baz()`,这将理所当然地调用我们内部的函数`bar()`,只不过是通过一个不同的标识符引用。

`bar()`被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域外部被执行的。

`foo()`被执行之后，一般来说我们会期望`foo()`的整个内部作用域都将消失，因为我们知道引擎启用了垃圾回收器在内存不再被使用时来回收它们。因为很显然`foo()`的内容不再被使用了，所以看起来它们很自然地应该被认为是消失了。

但是闭包的"魔法"不会让这发生。内部的作用域实际上依然"在使用"，因此不会消失。是谁在使用它？**函数bar()本身**。

有赖于它被声明的位置，`bar()`拥有一个词法作用域闭包覆盖着`foo()`的内部作用域，闭包为了能使`bar()`在以后任意的时刻可以引用这个作用域而保持它的存在。

**bar()依然拥有对那个作用域的引用，而这个引用称为闭包**。

所以，在几微妙之后，当变量`baz`被调用时(调用我们最开始标记为`bar`的内部函数),它理所应当地对编写时的词法作用域拥有访问权，所以它可以如我们所愿地访问变量`a`。

这个函数在它被编写时的词法作用域之外被调用。**闭包**使这个函数可以继续访问它在编写时被定义的词法作用域。

当然，函数可以被作为值传递，而且实际上在其他位置被调用的所有各种方式，都是观察/行使闭包的例子。

```js
function foo(){
  var a = 2;

  function baz(){
    console.log(a); // 2
  }

  bar(baz);
}

function bar(fn){
  fn();  
}

foo(); //2
```

我们将内部函数`baz`传递给`bar`,并调用这个内部函数(现在被标记为`fn`),当我们这么做时，它覆盖在`foo()`内部作用域的闭包就可以通过`a`的访问观察到。

这样的函数传递也可以是间接的。

```js
var fn;

function foo(){
  var a = 2;

  function baz(){
    console.log(a);
  }

  fn = baz; // 将`baz`赋值给一个全局变量
}

function bar(){
  fn(); // 闭包
}

foo();
bar(); // 2
```

无论我们使用什么方法将内部函数传递到它的词法作用域之外，它都将维护一个指向它最开始被声明时的作用域的引用，而且无论我们什么时候执行它，这个闭包就会被行使。

## 现在我能看到了

前面的代码有些学术化，而且是人工构建来说明闭包的使用的。但是我保证过给你的东西不止是一个新的酷玩具。我保证过闭包是在你的现在存在代码中无处不在的东西。

```js
function wait(message){
  setTimeout(function timer(){
    console.log(message);
  }, 1000);
}

wait("Hello, closure!");
```

我们拿来一个内部函数(名为`timer`)将它传递给`setTimeout(..)`。但是`timer`拥有覆盖`wait(..)`的作用域的闭包，实际上保持并使用着对变量`message`的引用。

在我们执行`wait(..)`一千毫秒之后，要不是内部函数，要不是内部函数`timer`依然覆盖着`wait()`内部作用域的闭包，它早就会消失了。

在引擎的内脏深处，内建的工具`setTimeout(..)`拥有一些参数的引用，可能称为`fn`或者`func`或者其他诸如此类的东西。引擎去调用这个函数，它调用我们内部`timer`函数，而词法作用域依然完好无损。

或者，如果你信仰jQuery(或者就此而言)

```js
function setupBot(name, selector){
  $(selector).click(function activator(){
    console.log("Activating:" + name);
  });
}

setupBot("Closure Bot 1", "#bot_1");
setupBot("Closure Bot 2", "#bot_2");
```

**注意**： 第三章介绍IIFE模式。虽然人们常说IIFE(独自)是一个可以观察到闭包的例子，但是根据我们上面定义，我有些不同意。

```js
var a = 2;

(function IIFE(){
  console.log(a);
})();
```

这段代码"好用"，但是严格来说它不是在观察闭包。为什么？因为这个函数(就是我们这里命名为"IIFE"的那个)没有在它的词法作用域之外执行。它仍然在它被声明的相同作用域中(那个同时持有`a`的外围/全局作用域)被调用。`a`是通过普通的词法作用域查询到的，不是通过真正的闭包。

虽说技术上的闭包可能发生在声明时，但它不是严格地可以观察到的，因此，就像人们说的，它是一颗在森林中倒掉的树，但周围没有人去听到它。

虽然IIFE本身不是一个闭包的例子，但是它绝对创建了作用域，而且它是我们用来创建可以被闭包的作用域的最常见工具之一。所以IIFE确实与闭包有强烈的关联，即使他们本身不行使闭包。

