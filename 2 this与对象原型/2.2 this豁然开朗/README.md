# 第二章：this豁然开朗

在第一章中，我们摒弃了种种对`this`的误解，并且知道了`this`是一个完全根据**调用点**(函数时如何被调用的)而为每次函数调用建立的绑定。

## 调用点(Call-site)

为了理解`this`绑定，我们不得不理解调用点:函数在代码中被调用的位置(**不是被声明的位置**)。我们必须考察调用点来回答这个问题：这个`this`指向什么？

一般来说寻找调用点就是："找到一个函数是在哪里被调用的", 但它不总是那么简单，比如某些特定的编码模式会使真正的调用点变得不那么明确。

考虑**调用栈(call-stack)**(使我们到达当前执行位置而被调用的所有方法的堆栈)是十分重要的。我们关心的调用点就位于当前执行中的函数之前的调用。

我们来展示一下调用栈和调用点：

```js
function baz(){
  // 调用栈是： `baz`
  // 我们的调用点是 global scope(全局作用域)

  console.log("baz");
  bar(); // <-- `bar` 的调用点
}

function bar(){
  // 调用栈是： `baz` -> `bar`
  // 我们的调用点位于 `baz`

  console.log("bar");
  foo(); // <-- `foo` 的 call-site
}

function foo(){
  // 调用栈是： `baz` -> `bar` -> `foo`
  // 我们的调用点位于 `bar`

  console.log("foo");
}

baz(); // <-- `baz`的调用点
```