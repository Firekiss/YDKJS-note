# 第三章：函数与块作用域

正如我们在第二章中探索的，作用域是由一系列"气泡"组成，这些"气泡"的每一个就像一个容器或篮子，标识符(变量，函数)就是在它里面被声明。这些气泡整齐地互相嵌套在一起，而其这种嵌套是在编写时定义的。

## 函数中的作用域

对于这些问题的最常见的回答是，JavaScript拥有基于函数的作用域。也就是，你声明的每一个函数为自己创建了一个气泡，而且没有其他的结构可以创建它们自己的作用域气泡。但是就像我们一会将会看到的，这不完全正确。

```js
function foo(a){
  var b = 2;

  function bar(){

  }

  var c = 3;
}
```

在这个代码段中,`foo(..)`的作用域气泡包含标识符`a`,`b`,`c`和`bar`。一个声明出现在作用域何处是**无关紧要的**，不管怎么样，变量和函数属于包含它们的作用域气泡。

`bar(..)`拥有它自己的气泡作用域。全局作用域也一样，它仅仅含有一个标识符：`foo`。

因为 `a`, `b`, `c`和`bar`都属于`foo(..)`的作用域气泡，所以它们在`foo(..)`外部是不可访问的。也就是，接下来的代码都会得到`ReferrenceError`错误，因为这些标识符在全局作用域中都不可用：

```js
bar(); //失败

console.log(a,b,c); // 3个都失败
```

然而，所有这些标识符(`a`,`b`,`c`,`bar`)在`foo(..)`内部都是可以访问的，而且在`bar(..)`内部也都是可用的(假定在`bar(..)`内部没有遮蔽标识符的声明)。

函数作用域支持着这样的想法：所有变量都属于函数，而且贯穿整个函数始终都可以使用和重用(而且甚至可以在嵌套的作用域中访问)。这种设计方式可以十分有用，而且肯定可以完全利用JavaScript的"动态"性质--变量可以根据需要接受不同种类的值。

另一方面，如果你不小心提防，跨越整个作用域存在的变量可能会导致一些意料之外的陷阱。

## 隐藏于普通作用域

考虑这个函数的传统方式是，你声明一个函数，并在它内部添加代码。但是相反的想法也同样强大和有用：拿你所编写的代码的任意一部分，在它的周围包装一个函数声明，这实质上"隐藏"了这段代码。

为什么"隐藏"变量和函数时一种有用的技术？

有多种原因驱使着这种基于作用域的隐藏。它们主要是由一种称为"最低权限原则"的软件设计原则引起的，有时候也被称为"最低授权"或"最少曝光"。这个原则规定，在软件设计中，比如一个模块/对象的API，你应当只暴露所需要的最低限度的东西，而"隐藏"其他的一切。

这个原则可以扩展到哪个作用域来包含变量和函数的选择。如果你所有的变量和函数都在全局作用域中，它们将理所当然地对任何嵌套的作用域来说都是可访问的。但是这会违背"最少......"原则，因为你(很可能)暴露了许多你本应当保持为私有的变量和函数，而这些代码的恰当用法是不鼓励访问这些变量/函数的。

```js
function doSomething(a){
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

function doSomethingElse(a){
  return a - 1;
}

var b;

doSomething(2); //15
```

在这个代码中，变量`b`和函数`doSomethingElse(..)`很可能是`doSomething(..)`如何工作的"私有"细节。允许外围作用域"访问"`b`和`doSomethingElse(..)`不仅没必要而且可能是"危险的",因为他们可能会以种种意外的方式，有意或无意地被使用，而且这也许违背了`doSomething(..)`假设的前提条件。

一个更"恰当"的设计是将这些细节隐藏在`doSomething(..)`的作用域内部。

```js
function doSomething(a){
  function doSomethingElse(a){
    return a - 1;
  }

  var b;
  
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

doSomething(2); //15
```
现在，`b`和`doSomethingElse(..)`对任何外界影响都是不可访问的，而是仅仅由`doSomething(..)`控制。它的功能和最终结果不受影响，但是这种设计将私有保持为私有的，这通常被认为是好的软件。

## 避免冲突

将变量和函数"隐藏"在一个作用域内部的另一个好处是，避免两个同名但用处不同的标识符之间发生无意的冲突。冲突经常导致值被以外地覆盖。

```js
function foo(){
  function bar(a){
    i = 3; // 在外围的for循环的作用域中改变`i`
    console.log(a + 1);
  }

  for(var i=0; i<10; i++){
    bar (i * 2); // 无限循环
  }
}

foo();
```

`bar(..)`内部的赋值`i = 3`意外地覆盖了在for循环中声明的`i`。在这个例子中，这将导致一个无限循环，因为`i`被设定为固定的值`3`,而将它永远`<10`。

`bar(..)`内部的赋值需要声明一个本地变量来使用，不论选用什么样的标识符名称。`var i = 3`；将修复这个问题(并将为`i`创建一个前面提到的"遮蔽变量"声明)。一个另外的选项，不是代替选项，是完全选择另外一个标识名称，比如`var j = 3`;但是你的软件设计也会自然而然地使用相同的标识符名称，所以在这种情况下利用作用域来"隐藏"你的内部声明是你最好/唯一的选择。

## 全局"名称空间"

变量冲突(很可能)发生的一个特别强有力的例子是在全局作用域中。当多个库被加载到你的程序中时，如果它们没有适当地隐藏他们的内部私有函数和变量，那么它们可以十分容易地互相冲突。

这样的库通常会在全局作用域中使用一个足够独特的名称来创建一个单独的变量名称，它经常是一个对象。然后这个对象被用作这个库的一个"名称空间"，所有要明确暴露出来的功能都被作为属性挂在这个对象(名称空间)上，而不是将它们自身作为顶层词法作用域的标识符。

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function(){
    // ...
  },
  doAnotherThing: function(){
    // ...
  }
};
```

## 模块管理

另一种回避冲突的选择是通过任意一种依赖管理器，使用更加现代的"模块"方式。使用这些工具，没有库可以向全局作用域添加任何标识符，取而代之的是使用依赖管理器的各种机制，要求库的标识符被明确地导入到另一个指定的作用域中。

因此，如果你选择这样做的话，你可以防御性地编码，并在实际上不使用依赖管理的情况下，取得与使用它们相同的结果。

## 函数作为作用域

我们已经看到，我们可以拿一段代码并在它周围包装一个函数，而这实质上对外部作用域"隐藏"了这个函数内部作用域包含的任何变量或函数声明。

```js
var a = 2;
function foo(){
  var a = 3;
  console.log(a); // 3
}
foo();

console.log(a); // 2
```

虽然这种技术"可以工作"，但是它不一定非常理想。它引入了一个问题。首先是我们不得不声明一个命名函数`foo()`,这意味着这个标识符名称`foo`本身就"污染"了外围作用域(在这个例子中是全局)。我们要不得不通过名称(`foo()`)明确地调用这个函数来使用被包装的代码真正运行。

如果这个函数不需要名称，而且如果这个函数能自动执行就更理想了。

```js
var a = 2;
(function foo(){
  var a = 3;
  console.log(a); // 3
})();
console.log(a); //2
```

首先注意，与仅仅是`function...`相对，这个包装函数语句以`(function...`开头。虽然这看起来像是一个微小的细节，但实际上这是一个重大的改变。与将这个函数视为一个标准的声明不同的是，这个函数被视为一个函数表达式。

**注意**：区别声明与表达式的最简单的方法是，这个语句中(不仅仅是一行，而是一个独立的语句)"function"一词的位置。如果"function"是这个语句中的第一个东西，那么它就是一个函数声明。否则就是一个函数表达式。

这里我们可以观察到一个函数声明或一个函数表达式之间的关键不同是，它的名称作为一个标识符被绑定在何处。

比较两段代码。在第一个代码段中，名称`foo`被绑定在外围作用域中，我们用`foo()`直接调用它。在第二个代码中，名称`foo`没有被绑定在外围作用域中，而是被绑定在它自己的函数内部。

胡换句话说,`(function foo(){...})`作为一个表达式意味着标识符`foo`仅能在`..`代表的作用域中被找到，而不是在外部作用域中。将名称`foo`隐藏在它自己内部意味着它不会没有必要地污染外围作用域。