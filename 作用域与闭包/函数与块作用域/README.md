# 第三章：函数与块作用域

正如我们在第二章中探索的，作用域是由一系列"气泡"组成，这些"气泡"的每一个就像一个容器或篮子，标识符(变量，函数)就是在它里面被声明。这些气泡整齐地互相嵌套在一起，而其这种嵌套是在编写时定义的。

## 函数中的作用域

对于这些问题的最常见的回答是，JavaScript拥有基于函数的作用域。也就是，你声明的每一个函数为自己创建了一个气泡，而且没有其他的结构可以创建它们自己的作用域气泡。但是就像我们一会将会看到的，这不完全正确。

```js
function foo(a){
  var b = 2;

  function bar(){

  }

  var c = 3;
}
```

在这个代码段中,`foo(..)`的作用域气泡包含标识符`a`,`b`,`c`和`bar`。一个声明出现在作用域何处是**无关紧要的**，不管怎么样，变量和函数属于包含它们的作用域气泡。

`bar(..)`拥有它自己的气泡作用域。全局作用域也一样，它仅仅含有一个标识符：`foo`。

因为 `a`, `b`, `c`和`bar`都属于`foo(..)`的作用域气泡，所以它们在`foo(..)`外部是不可访问的。也就是，接下来的代码都会得到`ReferrenceError`错误，因为这些标识符在全局作用域中都不可用：

```js
bar(); //失败

console.log(a,b,c); // 3个都失败
```

然而，所有这些标识符(`a`,`b`,`c`,`bar`)在`foo(..)`内部都是可以访问的，而且在`bar(..)`内部也都是可用的(假定在`bar(..)`内部没有遮蔽标识符的声明)。

函数作用域支持着这样的想法：所有变量都属于函数，而且贯穿整个函数始终都可以使用和重用(而且甚至可以在嵌套的作用域中访问)。这种设计方式可以十分有用，而且肯定可以完全利用JavaScript的"动态"性质--变量可以根据需要接受不同种类的值。

另一方面，如果你不小心提防，跨越整个作用域存在的变量可能会导致一些意料之外的陷阱。

## 隐藏于普通作用域

考虑这个函数的传统方式是，你声明一个函数，并在它内部添加代码。但是相反的想法也同样强大和有用：拿你所编写的代码的任意一部分，在它的周围包装一个函数声明，这实质上"隐藏"了这段代码。

为什么"隐藏"变量和函数时一种有用的技术？

有多种原因驱使着这种基于作用域的隐藏。它们主要是由一种称为"最低权限原则"的软件设计原则引起的，有时候也被称为"最低授权"或"最少曝光"。这个原则规定，在软件设计中，比如一个模块/对象的API，你应当只暴露所需要的最低限度的东西，而"隐藏"其他的一切。

这个原则可以扩展到哪个作用域来包含变量和函数的选择。如果你所有的变量和函数都在全局作用域中，它们将理所当然地对任何嵌套的作用域来说都是可访问的。但是这会违背"最少......"原则，因为你(很可能)暴露了许多你本应当保持为私有的变量和函数，而这些代码的恰当用法是不鼓励访问这些变量/函数的。

```js
function doSomething(a){
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

function doSomethingElse(a){
  return a - 1;
}

var b;

doSomething(2); //15
```

在这个代码中，变量`b`和函数`doSomethingElse(..)`很可能是`doSomething(..)`如何工作的"私有"细节。允许外围作用域"访问"`b`和`doSomethingElse(..)`不仅没必要而且可能是"危险的",因为他们可能会以种种意外的方式，有意或无意地被使用，而且这也许违背了`doSomething(..)`假设的前提条件。

一个更"恰当"的设计是将这些细节隐藏在`doSomething(..)`的作用域内部。

```js
function doSomething(a){
  function doSomethingElse(a){
    return a - 1;
  }

  var b;
  
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

doSomething(2); //15
```
现在，`b`和`doSomethingElse(..)`对任何外界影响都是不可访问的，而是仅仅由`doSomething(..)`控制。它的功能和最终结果不受影响，但是这种设计将私有保持为私有的，这通常被认为是好的软件。

## 避免冲突

将变量和函数"隐藏"在一个作用域内部的另一个好处是，避免两个同名但用处不同的标识符之间发生无意的冲突。冲突经常导致值被以外地覆盖。

```js
function foo(){
  function bar(a){
    i = 3; // 在外围的for循环的作用域中改变`i`
    console.log(a + 1);
  }

  for(var i=0; i<10; i++){
    bar (i * 2); // 无限循环
  }
}

foo();
```

`bar(..)`内部的赋值`i = 3`意外地覆盖了在for循环中声明的`i`。在这个例子中，这将导致一个无限循环，因为`i`被设定为固定的值`3`,而将它永远`<10`。

`bar(..)`内部的赋值需要声明一个本地变量来使用，不论选用什么样的标识符名称。`var i = 3`；将修复这个问题(并将为`i`创建一个前面提到的"遮蔽变量"声明)。一个另外的选项，不是代替选项，是完全选择另外一个标识名称，比如`var j = 3`;但是你的软件设计也会自然而然地使用相同的标识符名称，所以在这种情况下利用作用域来"隐藏"你的内部声明是你最好/唯一的选择。

## 全局"名称空间"

变量冲突(很可能)发生的一个特别强有力的例子是在全局作用域中。当多个库被加载到你的程序中时，如果它们没有适当地隐藏他们的内部私有函数和变量，那么它们可以十分容易地互相冲突。

这样的库通常会在全局作用域中使用一个足够独特的名称来创建一个单独的变量名称，它经常是一个对象。然后这个对象被用作这个库的一个"名称空间"，所有要明确暴露出来的功能都被作为属性挂在这个对象(名称空间)上，而不是将它们自身作为顶层词法作用域的标识符。

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function(){
    // ...
  },
  doAnotherThing: function(){
    // ...
  }
};
```
