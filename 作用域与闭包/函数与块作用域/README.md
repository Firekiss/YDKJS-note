# 第三章：函数与块作用域

正如我们在第二章中探索的，作用域是由一系列"气泡"组成，这些"气泡"的每一个就像一个容器或篮子，标识符(变量，函数)就是在它里面被声明。这些气泡整齐地互相嵌套在一起，而其这种嵌套是在编写时定义的。

## 函数中的作用域

对于这些问题的最常见的回答是，JavaScript拥有基于函数的作用域。也就是，你声明的每一个函数为自己创建了一个气泡，而且没有其他的结构可以创建它们自己的作用域气泡。但是就像我们一会将会看到的，这不完全正确。

```js
function foo(a){
  var b = 2;

  function bar(){

  }

  var c = 3;
}
```

在这个代码段中,`foo(..)`的作用域气泡包含标识符`a`,`b`,`c`和`bar`。一个声明出现在作用域何处是**无关紧要的**，不管怎么样，变量和函数属于包含它们的作用域气泡。

`bar(..)`拥有它自己的气泡作用域。全局作用域也一样，它仅仅含有一个标识符：`foo`。

因为 `a`, `b`, `c`和`bar`都属于`foo(..)`的作用域气泡，所以它们在`foo(..)`外部是不可访问的。也就是，接下来的代码都会得到`ReferrenceError`错误，因为这些标识符在全局作用域中都不可用：

```js
bar(); //失败

console.log(a,b,c); // 3个都失败
```

然而，所有这些标识符(`a`,`b`,`c`,`bar`)在`foo(..)`内部都是可以访问的，而且在`bar(..)`内部也都是可用的(假定在`bar(..)`内部没有遮蔽标识符的声明)。

函数作用域支持着这样的想法：所有变量都属于函数，而且贯穿整个函数始终都可以使用和重用(而且甚至可以在嵌套的作用域中访问)。这种设计方式可以十分有用，而且肯定可以完全利用JavaScript的"动态"性质--变量可以根据需要接受不同种类的值。

另一方面，如果你不小心提防，跨越整个作用域存在的变量可能会导致一些意料之外的陷阱。

## 隐藏于普通作用域

考虑这个函数的传统方式是，你声明一个函数，并在它内部添加代码。但是相反的想法也同样强大和有用：拿你所编写的代码的任意一部分，在它的周围包装一个函数声明，这实质上"隐藏"了这段代码。

为什么"隐藏"变量和函数时一种有用的技术？

有多种原因驱使着这种基于作用域的隐藏。它们主要是由一种称为"最低权限原则"的软件设计原则引起的，有时候也被称为"最低授权"或"最少曝光"。这个原则规定，在软件设计中，比如一个模块/对象的API，你应当只暴露所需要的最低限度的东西，而"隐藏"其他的一切。

这个原则可以扩展到哪个作用域来包含变量和函数的选择。如果你所有的变量和函数都在全局作用域中，它们将理所当然地对任何嵌套的作用域来说都是可访问的。但是这会违背"最少......"原则，因为你(很可能)暴露了许多你本应当保持为私有的变量和函数，而这些代码的恰当用法是不鼓励访问这些变量/函数的。

```js
function doSomething(a){
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

function doSomethingElse(a){
  return a - 1;
}

var b;

doSomething(2); //15
```

在这个代码中，变量`b`和函数`doSomethingElse(..)`很可能是`doSomething(..)`如何工作的"私有"细节。允许外围作用域"访问"`b`和`doSomethingElse(..)`不仅没必要而且可能是"危险的",因为他们可能会以种种意外的方式，有意或无意地被使用，而且这也许违背了`doSomething(..)`假设的前提条件。

一个更"恰当"的设计是将这些细节隐藏在`doSomething(..)`的作用域内部。

```js
function doSomething(a){
  function doSomethingElse(a){
    return a - 1;
  }

  var b;
  
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

doSomething(2); //15
```
现在，`b`和`doSomethingElse(..)`对任何外界影响都是不可访问的，而是仅仅由`doSomething(..)`控制。它的功能和最终结果不受影响，但是这种设计将私有保持为私有的，这通常被认为是好的软件。

## 避免冲突

将变量和函数"隐藏"在一个作用域内部的另一个好处是，避免两个同名但用处不同的标识符之间发生无意的冲突。冲突经常导致值被以外地覆盖。

```js
function foo(){
  function bar(a){
    i = 3; // 在外围的for循环的作用域中改变`i`
    console.log(a + 1);
  }

  for(var i=0; i<10; i++){
    bar (i * 2); // 无限循环
  }
}

foo();
```

`bar(..)`内部的赋值`i = 3`意外地覆盖了在for循环中声明的`i`。在这个例子中，这将导致一个无限循环，因为`i`被设定为固定的值`3`,而将它永远`<10`。

`bar(..)`内部的赋值需要声明一个本地变量来使用，不论选用什么样的标识符名称。`var i = 3`；将修复这个问题(并将为`i`创建一个前面提到的"遮蔽变量"声明)。一个另外的选项，不是代替选项，是完全选择另外一个标识名称，比如`var j = 3`;但是你的软件设计也会自然而然地使用相同的标识符名称，所以在这种情况下利用作用域来"隐藏"你的内部声明是你最好/唯一的选择。

## 全局"名称空间"

变量冲突(很可能)发生的一个特别强有力的例子是在全局作用域中。当多个库被加载到你的程序中时，如果它们没有适当地隐藏他们的内部私有函数和变量，那么它们可以十分容易地互相冲突。

这样的库通常会在全局作用域中使用一个足够独特的名称来创建一个单独的变量名称，它经常是一个对象。然后这个对象被用作这个库的一个"名称空间"，所有要明确暴露出来的功能都被作为属性挂在这个对象(名称空间)上，而不是将它们自身作为顶层词法作用域的标识符。

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function(){
    // ...
  },
  doAnotherThing: function(){
    // ...
  }
};
```

## 模块管理

另一种回避冲突的选择是通过任意一种依赖管理器，使用更加现代的"模块"方式。使用这些工具，没有库可以向全局作用域添加任何标识符，取而代之的是使用依赖管理器的各种机制，要求库的标识符被明确地导入到另一个指定的作用域中。

因此，如果你选择这样做的话，你可以防御性地编码，并在实际上不使用依赖管理的情况下，取得与使用它们相同的结果。

## 函数作为作用域

我们已经看到，我们可以拿一段代码并在它周围包装一个函数，而这实质上对外部作用域"隐藏"了这个函数内部作用域包含的任何变量或函数声明。

```js
var a = 2;
function foo(){
  var a = 3;
  console.log(a); // 3
}
foo();

console.log(a); // 2
```

虽然这种技术"可以工作"，但是它不一定非常理想。它引入了一个问题。首先是我们不得不声明一个命名函数`foo()`,这意味着这个标识符名称`foo`本身就"污染"了外围作用域(在这个例子中是全局)。我们要不得不通过名称(`foo()`)明确地调用这个函数来使用被包装的代码真正运行。

如果这个函数不需要名称，而且如果这个函数能自动执行就更理想了。

```js
var a = 2;
(function foo(){
  var a = 3;
  console.log(a); // 3
})();
console.log(a); //2
```

首先注意，与仅仅是`function...`相对，这个包装函数语句以`(function...`开头。虽然这看起来像是一个微小的细节，但实际上这是一个重大的改变。与将这个函数视为一个标准的声明不同的是，这个函数被视为一个函数表达式。

**注意**：区别声明与表达式的最简单的方法是，这个语句中(不仅仅是一行，而是一个独立的语句)"function"一词的位置。如果"function"是这个语句中的第一个东西，那么它就是一个函数声明。否则就是一个函数表达式。

这里我们可以观察到一个函数声明或一个函数表达式之间的关键不同是，它的名称作为一个标识符被绑定在何处。

比较两段代码。在第一个代码段中，名称`foo`被绑定在外围作用域中，我们用`foo()`直接调用它。在第二个代码中，名称`foo`没有被绑定在外围作用域中，而是被绑定在它自己的函数内部。

胡换句话说,`(function foo(){...})`作为一个表达式意味着标识符`foo`仅能在`..`代表的作用域中被找到，而不是在外部作用域中。将名称`foo`隐藏在它自己内部意味着它不会没有必要地污染外围作用域。

## 匿名与命名

你可能对函数表达式作为回调参数再熟悉不过了，比如：

```js
setTimeout(function(){
  console.log("I waited 1 second!");
}, 1000);
```

这称为一个"匿名函数表达式"，因为`function()...`上没有名称标识符。函数表达式可以是匿名的，但是函数声明不能省略名称--那将是不合法的JS程序。

匿名函数表达式可以快速和很容易的键入，而且许多库和工具往往鼓励使用这种代码管用风格。然而，它们有几个缺点需要考虑：

1. 在栈轨迹上匿名函数没有有用的名称可以表示，这可能会使得调试更加困难。
2. 没有名称的情况下，如果这个函数需要为了递归等目的引用它自己，那么就需要很不幸地使用**被废弃的**arguments.callee引用。另一个需要自引用的例子是，当一个事件处理器函数在被触发后想要把自己解除绑定。
3. 匿名函数省略的名称经常对提供更易读/易懂的代码很有帮助。一个描述性的名称可以可以帮助代码自解释。

**内联函数表达式**很强大且很有用 --- 匿名和命名的问题并不会贬损这一点。给你的函数表达式提供一个名称就可以十分有效地解决这些缺陷，而且没有实际的坏处。最佳的方法是总是命名你的函数表达式：

```js
setTimeout(function timeoutHandler(){
  console.log("I waited 1 second!");
}, 1000);
```

## 立即调用函数表达式

```js
var a = 2;
(function foo(){
  var a = 3;
  console.log(a); // 3
})();

console.log(a); // 2
```

得益于包装在一个`()`中，我们有了一个作为表达式的函数，我们可以通过在末尾加入一个`()`来执行这个函数，就像`(function foo(){..})()`。第一个外围的`()`使这个函数变成表达式，而第二个`()`执行这个函数。

这个模式是如此常见，以至于几年前开发者社区一致同意给它一个术语：IIFE，它表示"立即被调用的函数表达式"(Immediately Invoked Function Expression)。

当然，IIFE不一定需要一个名称，IIFE的最常见形式是使用一个匿名函数表达式。虽然少见一些，但与匿名函数表达式相比，命名的IIFE拥有前述所有的好处，所以它是一个可以采用的好方式。

```js
var a = 2;
(function IIFE(){
  var a = 3;
  console.log(a); // 3
})();

console.log(a); //2
```

传统的IIFE有一种悄悄变化的形式，一些人偏好这样：`(function(){..}())`。仔细观察不同之处。在第一种形式中，函数表达式被包在`()`中，然后用于调用的`()`出现在它的外侧。在第二种形式中，用于调用的`()`被移动到用于包装的`()`内侧。

这两种形式在功能上完全相同。**这存粹是一个你偏好的风格的选择**。

IIFE的另一种常见的变种是，利用他们实际上只是函数调用的事实，来传入参数值。

例如：

```js
var a = 2;

(function IIFE(global){
  var a = 3;
  console.log(a); // 3
  console.log(global.a);  // 2
})(window);

console.log(a); //2
```

我们传入`window`对应引用，但是我们将参数命名为`global`,这样我们对于全局和非全局引用就有了一个清晰的文体上的划分。当然，你可以从外围作用域传入任何你想要的东西，而且你可以将参数命名为任何适合你的名称。这几乎仅仅是文体上的选择。

这种模式的另一种应用解决了一个小问题：默认的`undefiend`标识符的值也许会被不正确地覆盖掉，而导致意外的结果。通过将参数命名为`undefined`,同时不为它传递任何参数值，我们就可以保证在一个代码中`undefined`标识符确实是一个未定义的值。

```js
undefined = true;  // 给其他的代码埋雷！别这么干！

(function IIFE(undefined){
  var a;
  if(a === undefined){
    console.log("Undefined is safe here!");
  }
})();
```

IIFE还有一种变种，它将事情和顺序倒了过来，要被执行的函数在调用和传递给它的参数之后给出。这种模式被用于UMD(Universal Module Definition --- 统一模块定义) 项目。一些人发现它更干净和易懂一些，虽然有点儿繁冗。

```js
var a = 2;

(function IIFE(def){
  def(window);
})(function def(global){
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});
```

`def`函数表达式在这个代码段的后半部分被定义，然后作为一个参数(也叫`def`)被传递给在代码段前半部分定义的`IIFE`函数。最后，参数`def`(函数)被调用，并将window作为`global`参数传入。

## 块儿作为作用域

虽然函数时最常见的作用域单位，而且当然也是在世界上流通的绝大多数js中最为广泛传播的设计方式，但是其他的作用域单位也是可能的，而且使用这些作用域单位可以导致更好、对于维护来说更干净的代码。

JavaScript之外的许多其他语言都支持块儿作用域，所以有这些语言背景的开发者习惯于这种 思维模式，然而那些主要在JavaScript中工作的开发者可能会发现这个概念有些陌生。

但即使你从没有块儿作用域的方式写过一行代码，你可能依然对JavaScript中这种极其常见的管用法很熟悉：

```js
for(var i=0;i<10;i++){
  console.log(i);
}
```

我们在for循环头部的内部直接声明了变量`i`，因为我们意图很可能是仅在这个for循环内部的上下文环境中使用`i`,而实质上忽略了这个变量实际上讲自己划入了外围作用域中(函数或全局)的事实。

这就是有关块儿作用域的一切。尽可能靠近地，尽可能局部地，在变量将被使用的位置声明它。另一个例子是：

```js
var foo = true;
if(foo){
  var bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}
```

我们仅仅在if语句的上下文环境中使用变量`bar`,所以我们将它声明在if块儿的内部是有些道理的。然而，当使用`var`时，我们在何处声明变量是无关紧要的，因为它们总是属于外围作用域。这个代码段实质上为了代码风格的原因"假冒"了块儿作用域，并依赖于我们要管好自己，不在要在这个作用域的其他地方以外地使用`bar`。

从将信息隐藏在函数中，到将信息隐藏在我们代码的块儿中，块儿作用域是一种扩展了早点的"最低 暴露原则"的工具。

再次考虑这个for循环的例子：

```js
for(var i=0;i<10;i++){
  console.log(i);
}
```

为什么要用仅将(或者至少是，仅应当)在这个for循环中使用的变量`i`去污染一个函数的整个作用域呢？

但更重要的是，开发者们也许偏好于检查他们自己来防止在变量预期的目的之外意外地(重)使用它们，例如如果你试着在错误的地方使用变量会导致一个未知变量的错误。对于变量`i`的块儿作用域(如果它是可能的话)将使`i`仅在for循环内部可用，使得如果在函数其他地方访问`i`将导致一个错误。这有助于保证变量不会被糊涂地重用或者难于维护。

但是，悲惨的现实是，JavaScript没有块儿作用域的能力。

更确切地说，直到你再深入一些才有。

## with

我们在第二章中学习了`with`。虽然它是一个使人皱眉头的结构，但它确实是一个(一种形式的)块儿作用域的例子，它从对象中创建的作用域仅存在于这个`with`语句的生命周期中，而不是外围作用域中。

## try/catch

一个鲜为人知的事实是，JavaScript在ES3中明确指出在`try/catch`的`catch`子语句声明的变量，是属于`catch`块儿的块儿作用域的。

例如：

```js
try{
  undefined(); // 用非法的操作强制产生一个异常!
}
catch (err){
  console.log(err); // 好用！
}

console.log(err); //ReferrenceError: 'err' not found
```

如你所见，`err`仅存在于`catch`子句中，并且在你试着从其他地方引用它时抛出一个错误。

**注意**:虽然这种行为已经被明确规定，而且对于几乎所有的标准的JS环境来说都是成立的，但是如果你在同一个作用域中有两个或多个`catch`子句，而它们又各自用相同的标识符名称声明了它们表示错误的变量时，许多linter依然会报警。实际上这不是重定义，因为这些变量都安全地位于块儿作用域中，但是linter看起来依然会恼人地抱怨这个事实。

为了避免这些不必要的警告，一些开发者将它们的catch变量命名为`err1`,`err2`,另一些开发者干脆关闭linter对重复变量名的检查。

`catch`的块儿作用域性质看起来像是一个没用的，但有学院派意义的事实。