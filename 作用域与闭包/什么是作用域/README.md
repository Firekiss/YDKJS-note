# 第一章

提出问题

1. js中的变量存储在哪儿
2. 程序如何在需要的时候找到它们

## 编译器理论

尽管JavaScript一般被划分到"动态"或者"解释型"语言的范畴，但是实际它是一个**编译型**语言。只不过它不像许多传统意义上的编译型语言那样预先被编译好，编译结果也不能在各个不同的分布式系统间移植。

传统的编译型语言处理中，源代码在执行前会经历三个步骤，大致称为"编译":

1. 分词/词法分析：将一连串字符打断成有意义的片段，称为token。
2. 解析： 将一个token的流(数组)转换为一个嵌套元素的树，它综合地展示了程序的语法结构。这棵树称为"抽象语法树"。
3. 代码生成：这个处理将抽象语法树转换为可执行的代码。

任何js代码在它执行前(通常是刚好在它执行前！)都必须被编译。所以，js编译器将把程序`var a = 2`;拿过来，首先编译它，然后准备运行它，通常是立即的。

## 理解作用域

### 演员

处理程序`var a = 2;`时进行互动的演员

1. 引擎：负责从始至终的编译和执行我们的js程序。
2. 编译器：引擎的朋友之一；处理所有的解析和代码生成的重活儿。 
3. 作用域：引擎的另一个朋友；收集并维护一张所有被声明的标识符(变量)的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。

### 反复

编译器处理：

1. 遇到`var a`,编译器让作用域去查看对于这个特定的作用域集合，变量`a`是否已经存在了。如果是，编译器就忽略这个声明并继续前进。否则，编译器就让作用域为这个作用域集合声明一个称为`a`的新变量。
2. 然后编译器为引擎生成稍后要执行的代码，来处理赋值`a = 2`。引擎运行的代码首先让作用域去查看在当前的作用域集合中是否有一个称为`a`的变量可以访问。如果有，引擎就使用这个变量。如果没有，引擎就查看其它地方(作用域嵌套)。

如果引擎最终找到了一个变量，它就将值`2`赋予它。如果没有，引擎将会举起它的手并喊出错误。

### 编译术语

当引擎执行编译器在第二步为它产生的代码时，它必须查询变量`a`看它是否已经被声明过了，而且这个查询是资讯作用域的。但是引擎所实施的查询的类型会影响查询的结果。

在我们的例子中，引擎将会对变量`a`实施一个"LHS"查询。另一种类型的查询称为"RHS"。
当一个变量出现在赋值操作的左手边时，会进行LHS查询，当一个变量出现在赋值操作的右边时，会进行RHS查询。

RHS是难以察觉的，因为它简单地查询某个变量的值，而LHS查询是试着找到变量容器本身，以便它可以赋值。

```js
console.log(a);
```

这个指向`a`的引用是一个RHS引用，因为这里没有东西被赋值给`a`。而是我们在查询`a`并且取它的值，这样这个值可以被传递进`console.log(...)`。

**注意**: LHS和RHS意味着"赋值的左/右手边"未必像字面上那样意味着"=赋值操作符的左/右边"。赋值有几种其他的发生形式，所以最好在概念上讲它考虑为："赋值的目标(LHS)和赋值的源(RHS)"。